/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\nconst _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\nconst _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\nconst _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\nconst _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;\nconst _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;\n\n/**\n * A 2d vector\n * @typedef {Object} vec2\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new 2d vector\n * @param {number|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec2} A new 2d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec2(3, 2); // (3, 2)\n * let b = vec2(4);    // (4, 4)\n * let c = vec2(a);    // (3, 2)\n * let d = vec2();     // (0, 0)\n */\nconst vec2 = (x, y) => {\n  if (!x && !y) {\n    return { x: 0, y: 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0 };\n  }\n  return { x: x, y: y ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec2} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec2.components = a => [a.x, a.y];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec2} A new vector\n */\nvec2.fromComponents = components => vec2(...components.slice(0, 2));\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec2} A unit vector (1, 0)\n */\nvec2.ux = () => vec2(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec2} A unit vector (0, 1)\n */\nvec2.uy = () => vec2(0, 1);\n\n/**\n * Add vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a + b\n */\nvec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a - b\n */\nvec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });\n\n/**\n * Scale a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a * b\n */\nvec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec2.mul\n * @param {vec2} a Vector a\n * @param {number} b Scalar b\n * @return {vec2} a * b\n */\nvec2.scale = (a, b) => vec2.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a / b\n */\nvec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec2} a The vector to normalise\n * @return {vec2} ^a\n */\nvec2.nor = a => {\n  let len = vec2.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec2();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a ∙ b\n */\nvec2.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec2} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec2} A rotated vector\n */\nvec2.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n};\n\n/**\n * Fast method to rotate a vector by -90, 90 or 180 degrees\n * @param {vec2} a The vector to rotate\n * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees\n * @return {vec2} A rotated vector\n */\nvec2.rotf = (a, r) => {\n  switch (r) {\n    case 1: return vec2(a.y, -a.x);\n    case -1: return vec2(-a.y, a.x);\n    case 2: case -2: return vec2(-a.x, -a.y);\n    default: return a;\n  }\n};\n\n/**\n * Scalar cross product of two vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a × b\n */\nvec2.cross = (a, b) => {\n  return a.x * b.y - a.y * b.x;\n};\n\n/**\n * Check if two vectors are equal\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec2.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec2} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec2.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec2} a The vector to copy\n * @return {vec2} A copy of vector a\n */\nvec2.cpy = a => vec2(a);\n\n/**\n * A function to call on each component of a 2d vector\n * @callback vec2MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec2} a Vector a\n * @param {vec2MapCallback} f The function to call on each component of the vector\n * @return {vec2} Vector a mapped through f\n */\nvec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec2} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x` or `y`\n * - `u` or `v` (aliases for `x` and `y`, respectively)\n * - `X`, `Y`, `U`, `V` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec2} a The vector to swizzle\n * @param {string} [s='..'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec2(3, -2);\n * vec2.swiz(a, 'x');    // [3]\n * vec2.swiz(a, 'yx');   // [-2, 3]\n * vec2.swiz(a, 'xY');   // [3, 2]\n * vec2.swiz(a, 'Yy');   // [2, -2]\n * vec2.swiz(a, 'x.x');  // [3, -2, 3]\n * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]\n */\nvec2.swiz = (a, s = '..') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': result.push(a.x); break;\n      case 'y': case 'v': result.push(a.y); break;\n      case 'X': case 'U': result.push(-a.x); break;\n      case 'Y': case 'V': result.push(-a.y); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 2d vector\n * @typedef {Object} polarCoordinates2d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec2} a The vector to convert\n * @return {polarCoordinates2d} The magnitude and angle of the vector\n */\nvec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The angle of the vector\n * @return {vec2} A vector with the given angle and magnitude\n */\nvec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));\n\n/**\n * A 3d vector\n * @typedef {Object} vec3\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n * @property {number} z The z component of the vector\n */\n\n/**\n * Create a new 3d vector\n * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector, or the z component if x is a vec2\n * @param {number} [z] The z component of the vector\n * @return {vec3} A new 3d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec3(3, 2, 1);       // (3, 2, 1)\n * let b = vec3(4, 5);          // (4, 5, 0)\n * let c = vec3(6);             // (6, 6, 6)\n * let d = vec3(a);             // (3, 2, 1)\n * let e = vec3();              // (0, 0, 0)\n * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)\n * let g = vec3(vec2(4, 5));    // (4, 5, 0)\n */\nconst vec3 = (x, y, z) => {\n  if (!x && !y && !z) {\n    return { x: 0, y: 0, z: 0 };\n  }\n  if (_vec_is_vec3(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: y || 0 };\n  }\n  return { x: x, y: y ?? x, z: z ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec3} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec3.components = a => [a.x, a.y, a.z];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec3} A new vector\n */\nvec3.fromComponents = components => vec3(...components.slice(0, 3));\n\n/**\n * Return a unit vector (1, 0, 0)\n * @return {vec3} A unit vector (1, 0, 0)\n */\nvec3.ux = () => vec3(1, 0, 0);\n\n/**\n * Return a unit vector (0, 1, 0)\n * @return {vec3} A unit vector (0, 1, 0)\n */\nvec3.uy = () => vec3(0, 1, 0);\n\n/**\n * Return a unit vector (0, 0, 1)\n * @return {vec3} A unit vector (0, 0, 1)\n */\nvec3.uz = () => vec3(0, 0, 1);\n\n/**\n * Add vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a + b\n */\nvec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a - b\n */\nvec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });\n\n/**\n * Scale a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a * b\n */\nvec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec3.mul\n * @param {vec3} a Vector a\n * @param {number} b Scalar b\n * @return {vec3} a * b\n */\nvec3.scale = (a, b) => vec3.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a / b\n */\nvec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);\n\n/**\n * Normalise a vector\n * @param {vec3} a The vector to normalise\n * @return {vec3} ^a\n */\nvec3.nor = a => {\n  let len = vec3.len(a);\n  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {number} a ∙ b\n */\nvec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;\n\n/**\n * Rotate a vector using a rotation matrix\n * @param {vec3} a The vector to rotate\n * @param {mat} m The rotation matrix\n * @return {vec3} A rotated vector\n */\nvec3.rot = (a, m) => vec3(\n  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)\n);\n\n/**\n * Rotate a vector by r radians around the x axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotx = (a, r) => vec3(\n  a.x,\n  a.y * Math.cos(r) - a.z * Math.sin(r),\n  a.y * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the y axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.roty = (a, r) => vec3(\n  a.x * Math.cos(r) + a.z * Math.sin(r),\n  a.y,\n  -a.x * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the z axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotz = (a, r) => vec3(\n  a.x * Math.cos(r) - a.y * Math.sin(r),\n  a.x * Math.sin(r) + a.y * Math.cos(r),\n  a.z\n);\n\n/**\n * Rotate a vector using a quaternion\n * @param {vec3} a The vector to rotate\n * @param {Array<number>} q The quaternion to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rotq = (v, q) => {\n  if (q.length !== 4) {\n    return vec3();\n  }\n\n  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);\n  if (d === 0) {\n    return vec3();\n  }\n\n  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];\n  const u = vec3(...uq.slice(0, 3));\n  const s = uq[3];\n  return vec3.add(\n    vec3.add(\n      vec3.mul(u, 2 * vec3.dot(u, v)),\n      vec3.mul(v, s * s - vec3.dot(u, u))\n    ),\n    vec3.mul(vec3.cross(u, v), 2 * s)\n  );\n};\n\n/**\n * Rotate a vector using Euler angles\n * @param {vec3} a The vector to rotate\n * @param {vec3} e The Euler angles to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);\n\n/**\n * Get the cross product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {vec3} a × b\n */\nvec3.cross = (a, b) => vec3(\n  a.y * b.z - a.z * b.y,\n  a.z * b.x - a.x * b.z,\n  a.x * b.y - a.y * b.x\n);\n\n/**\n * Check if two vectors are equal\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;\n\n/**\n * Get the angle of a vector from the x axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radx = a => Math.atan2(a.z, a.y);\n\n/**\n * Get the angle of a vector from the y axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.rady = a => Math.atan2(a.x, a.y);\n\n/**\n * Get the angle of a vector from the z axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radz = a => Math.atan2(a.y, a.z);\n\n/**\n * Copy a vector\n * @param {vec3} a The vector to copy\n * @return {vec3} A copy of vector a\n */\nvec3.cpy = a => vec3(a);\n\n/**\n * A function to call on each component of a 3d vector\n * @callback vec3MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y' | 'z'} label The component label (x, y or z)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec3} a Vector a\n * @param {vec3MapCallback} f The function to call on each component of the vector\n * @return {vec3} Vector a mapped through f\n */\nvec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });\n\n/**\n * Convert a vector into a string\n * @param {vec3} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x`, `y` or `z`\n * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)\n * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)\n * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec3} a The vector to swizzle\n * @param {string} [s='...'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec3(3, -2, 1);\n * vec3.swiz(a, 'x');     // [3]\n * vec3.swiz(a, 'zyx');   // [1, -2, 3]\n * vec3.swiz(a, 'xYZ');   // [3, 2, -1]\n * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]\n * vec3.swiz(a, 'x.x');   // [3, -2, 3]\n * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]\n */\nvec3.swiz = (a, s = '...') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': case 'r': result.push(a.x); break;\n      case 'y': case 'v': case 'g': result.push(a.y); break;\n      case 'z': case 'w': case 'b': result.push(a.z); break;\n      case 'X': case 'U': case 'R': result.push(-a.x); break;\n      case 'Y': case 'V': case 'G': result.push(-a.y); break;\n      case 'Z': case 'W': case 'B': result.push(-a.z); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 3d vector\n * @typedef {Object} polarCoordinates3d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The tilt angle of the vector\n * @property {number} phi The pan angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec3} a The vector to convert\n * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector\n */\nvec3.polar = a => {\n  let r = vec3.len(a),\n    theta = Math.acos(a.y / r),\n    phi = Math.atan2(a.z, a.x);\n  return { r, theta, phi };\n};\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The tilt of the vector\n * @param {number} phi The pan of the vector\n * @return {vec3} A vector with the given angle and magnitude\n */\nvec3.fromPolar = (r, theta, phi) => {\n  const sinTheta = Math.sin(theta);\n  return vec3(\n    r * sinTheta * Math.cos(phi),\n    r * Math.cos(theta),\n    r * sinTheta * Math.sin(phi)\n  );\n};\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|false} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Multiply a matrix by a vector\n * @param {mat} a Matrix a\n * @param {vec2|vec3|number[]} b Vector b\n * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied\n */\nmat.mulv = (a, b) => {\n  let n, bb, rt;\n  if (_vec_is_vec3(b)) {\n    bb = vec3.components(b);\n    n = 3;\n    rt = vec3.fromComponents;\n  } else if (_vec_is_vec2(b)) {\n    bb = vec2.components(b);\n    n = 2;\n    rt = vec2.fromComponents;\n  } else {\n    bb = b;\n    n = b.length ?? 0;\n    rt = v => v;\n  }\n  if (a.n !== n) { return false; }\n  const result = [];\n  for (let i = 1; i <= a.m; i++) {\n    result.push(_vec_dot(mat.row(a, i), bb));\n  }\n  return rt(result);\n}\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|false} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|false} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|false} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec2, vec3, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/sprite/./node_modules/@basementuniverse/vec/vec.js?");

/***/ }),

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.spriteOptionsContentProcessor = exports.Sprite = exports.isSpriteOptionsData = exports.SpriteAnimationRepeatMode = void 0;\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nvar SpriteAnimationRepeatMode;\n(function (SpriteAnimationRepeatMode) {\n    /**\n     * Loop this animation indefinitely\n     */\n    SpriteAnimationRepeatMode[\"Repeat\"] = \"repeat\";\n    /**\n     * Play once and then stop on the last frame\n     */\n    SpriteAnimationRepeatMode[\"PlayOnceAndStop\"] = \"play-once-and-stop\";\n    /**\n     * Play once and then reset back to the first frame\n     */\n    SpriteAnimationRepeatMode[\"PlayOnceAndReset\"] = \"play-once-and-reset\";\n})(SpriteAnimationRepeatMode = exports.SpriteAnimationRepeatMode || (exports.SpriteAnimationRepeatMode = {}));\n// -----------------------------------------------------------------------------\n// TYPE GUARDS\n// -----------------------------------------------------------------------------\nfunction isVec2(value) {\n    return (typeof value === 'object' &&\n        value !== null &&\n        'x' in value &&\n        'y' in value &&\n        typeof value.x === 'number' &&\n        typeof value.y === 'number');\n}\nfunction isSpriteAnimationOptionsData(value) {\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n    if (!('name' in value) || typeof value.name !== 'string') {\n        return false;\n    }\n    if (!('frameCount' in value) || typeof value.frameCount !== 'number') {\n        return false;\n    }\n    if (!('frameRate' in value) || typeof value.frameRate !== 'number') {\n        return false;\n    }\n    if (!('mode' in value) ||\n        !Object.values(SpriteAnimationRepeatMode).includes(value.mode)) {\n        return false;\n    }\n    if ('imageNames' in value) {\n        if (!Array.isArray(value.imageNames)) {\n            return false;\n        }\n        if (!value.imageNames.every((imageName) => typeof imageName === 'string')) {\n            return false;\n        }\n    }\n    if ('attachmentPointKeyframes' in value &&\n        typeof value.attachmentPointKeyframes === 'object' &&\n        value.attachmentPointKeyframes !== null) {\n        for (const [attachmentPointName, keyframes] of Object.entries(value.attachmentPointKeyframes)) {\n            if (typeof attachmentPointName !== 'string') {\n                return false;\n            }\n            if (!Array.isArray(keyframes)) {\n                return false;\n            }\n            if (!keyframes.every(isSpriteAttachmentPointKeyframe)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction isSpriteAttachmentPointOptions(value) {\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n    if (!('name' in value) || typeof value.name !== 'string') {\n        return false;\n    }\n    if (!('offset' in value) || !isVec2(value.offset)) {\n        return false;\n    }\n    return true;\n}\nfunction isSpriteAttachmentPointKeyframe(value) {\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n    if (!('frame' in value) || typeof value.frame !== 'number') {\n        return false;\n    }\n    if (!('offset' in value) || !isVec2(value.offset)) {\n        return false;\n    }\n    return true;\n}\nfunction isSpriteOptionsData(value) {\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n    if ('position' in value && !isVec2(value.position)) {\n        return false;\n    }\n    if ('size' in value && !isVec2(value.size)) {\n        return false;\n    }\n    if ('origin' in value && !isVec2(value.origin)) {\n        return false;\n    }\n    if ('scale' in value && typeof value.scale !== 'number') {\n        return false;\n    }\n    if ('rotation' in value && typeof value.rotation !== 'number') {\n        return false;\n    }\n    if ('directions' in value && !Array.isArray(value.directions)) {\n        return false;\n    }\n    if ('defaultDirection' in value &&\n        typeof value.defaultDirection !== 'string') {\n        return false;\n    }\n    if ('imageName' in value && typeof value.imageName !== 'string') {\n        return false;\n    }\n    if ('animations' in value) {\n        if (typeof value.animations !== 'object' || value.animations === null) {\n            return false;\n        }\n        for (const [animationName, animationDirections] of Object.entries(value.animations)) {\n            if (typeof animationName !== 'string') {\n                return false;\n            }\n            if (typeof animationDirections !== 'object' ||\n                animationDirections === null) {\n                return false;\n            }\n            for (const [directionName, animationOptions] of Object.entries(animationDirections)) {\n                if (typeof directionName !== 'string') {\n                    return false;\n                }\n                if (!isSpriteAnimationOptionsData(animationOptions)) {\n                    return false;\n                }\n            }\n        }\n    }\n    if ('defaultAnimation' in value &&\n        typeof value.defaultAnimation !== 'string') {\n        return false;\n    }\n    if ('attachmentPoints' in value) {\n        if (!Array.isArray(value.attachmentPoints)) {\n            return false;\n        }\n        if (!value.attachmentPoints.every(isSpriteAttachmentPointOptions)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isSpriteOptionsData = isSpriteOptionsData;\n// -----------------------------------------------------------------------------\n// SPRITE CLASS\n// -----------------------------------------------------------------------------\nclass Sprite {\n    constructor(options) {\n        var _a, _b;\n        this.position = (0, vec_1.vec2)();\n        this.size = (0, vec_1.vec2)();\n        this.origin = (0, vec_1.vec2)();\n        this.scale = 1;\n        this.rotation = 0;\n        this.currentAnimationOptions = null;\n        this.currentAnimationState = null;\n        this.currentImage = null;\n        this.currentAttachmentPoints = null;\n        const actualOptions = Object.assign({}, Sprite.DEFAULT_OPTIONS, options !== null && options !== void 0 ? options : {});\n        for (const animation of Object.keys(actualOptions.animations)) {\n            for (const direction of Object.keys(actualOptions.animations[animation])) {\n                actualOptions.animations[animation][direction] = Object.assign({}, Sprite.DEFAULT_ANIMATION_OPTIONS, actualOptions.animations[animation][direction]);\n            }\n        }\n        if (!actualOptions.debug || actualOptions.debug === true) {\n            actualOptions.debug = {\n                showSpriteTransforms: !!actualOptions.debug,\n                showSpriteBoundingBox: !!actualOptions.debug,\n                showAttachmentPoints: !!actualOptions.debug,\n            };\n        }\n        this.options = actualOptions;\n        if (this.options.position) {\n            this.position = vec_1.vec2.cpy(this.options.position);\n        }\n        if (this.options.size) {\n            this.size = vec_1.vec2.cpy(this.options.size);\n        }\n        else {\n            // Default to the size of the base image if one exists\n            if (this.options.image) {\n                this.size = (0, vec_1.vec2)(this.options.image.width, this.options.image.height);\n            }\n            else {\n                // Fall back to the size of the image in the first frame of the first\n                // available direction of the default animation if one exists\n                const defaultAnimationDirections = Object.values(this.options.animations[this.options.defaultAnimation])[0];\n                if (defaultAnimationDirections &&\n                    ((_b = (_a = defaultAnimationDirections.images) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) > 0) {\n                    this.size = (0, vec_1.vec2)(defaultAnimationDirections.images[0].width, defaultAnimationDirections.images[0].height);\n                }\n            }\n            // Otherwise leave the size as (0, 0)\n        }\n        if (this.options.origin) {\n            this.origin = vec_1.vec2.cpy(this.options.origin);\n        }\n        else {\n            // Default to the center of the sprite based on size\n            this.origin = vec_1.vec2.mul(this.size, 0.5);\n        }\n        if (this.options.scale) {\n            this.scale = this.options.scale;\n        }\n        if (this.options.rotation) {\n            this.rotation = this.options.rotation;\n        }\n        // Check and initialise direction\n        this._direction = this.options.defaultDirection;\n        if (this.options.directions.length === 0 ||\n            !this.options.directions.includes(this._direction)) {\n            throw new Error(`Invalid direction \"${this._direction}\"`);\n        }\n        // Check and initialise animation\n        this._animation = this.options.defaultAnimation;\n        const animations = Object.keys(this.options.animations);\n        if (animations.length === 0 || !animations.includes(this._animation)) {\n            throw new Error(`Invalid animation \"${this._animation}\"`);\n        }\n        // Make sure attachment point keyframes are defined in ascending\n        // frame order in all animations\n        for (const animation of Object.keys(this.options.animations)) {\n            for (const direction of Object.keys(this.options.animations[animation])) {\n                if (this.options.animations[animation][direction].attachmentPointKeyframes) {\n                    for (const attachmentPoint of Object.keys(this.options.animations[animation][direction]\n                        .attachmentPointKeyframes)) {\n                        this.options.animations[animation][direction].attachmentPointKeyframes[attachmentPoint].sort((a, b) => a.frame - b.frame);\n                    }\n                }\n            }\n        }\n    }\n    get direction() {\n        return this._direction;\n    }\n    set direction(value) {\n        if (this.options.directions.includes(value)) {\n            this._direction = value;\n        }\n    }\n    get animation() {\n        return this._animation;\n    }\n    set animation(value) {\n        var _a, _b, _c, _d;\n        if (Object.keys(this.options.animations).includes(value)) {\n            const previous = this._animation;\n            this._animation = value;\n            // When switching animations, we might be part-way through and the\n            // new animation might have fewer frames, in which case we should clamp\n            // the current frame number\n            const currentFrameCount = (_b = (_a = this.options.animations[value][this.direction]) === null || _a === void 0 ? void 0 : _a.frameCount) !== null && _b !== void 0 ? _b : 1;\n            const previousFrameCount = (_d = (_c = this.options.animations[previous][this.direction]) === null || _c === void 0 ? void 0 : _c.frameCount) !== null && _d !== void 0 ? _d : 1;\n            if (currentFrameCount < previousFrameCount &&\n                this.currentAnimationState &&\n                this.currentAnimationState.currentFrame >= currentFrameCount) {\n                this.currentAnimationState.currentFrame = currentFrameCount - 1;\n            }\n        }\n    }\n    playAnimation() {\n        if (this.currentAnimationState) {\n            this.currentAnimationState.playing = true;\n        }\n    }\n    pauseAnimation() {\n        if (this.currentAnimationState) {\n            this.currentAnimationState.playing = false;\n        }\n    }\n    resetAnimation() {\n        if (this.currentAnimationState) {\n            this.currentAnimationState.currentFrame = 0;\n            this.currentAnimationState.currentFrameTime = 0;\n        }\n    }\n    getAttachmentPoint(name) {\n        var _a, _b;\n        return (_b = (_a = this.currentAttachmentPoints) === null || _a === void 0 ? void 0 : _a[name]) !== null && _b !== void 0 ? _b : null;\n    }\n    update(dt) {\n        this.currentAnimationOptions = this.updateAnimationOptions();\n        this.currentAnimationState = this.updateAnimationState(dt);\n        this.currentImage = this.updateImage();\n        this.currentAttachmentPoints = this.updateAttachmentPoints();\n    }\n    updateAnimationOptions() {\n        if (!(this._animation in this.options.animations)) {\n            throw new Error(`Invalid animation \"${this._animation}\"`);\n        }\n        const directions = Object.keys(this.options.animations[this._animation]);\n        if (directions.length === 0) {\n            throw new Error(`No directions available for animation \"${this._animation}\"`);\n        }\n        if (this._direction in this.options.animations[this._animation]) {\n            return this.options.animations[this._animation][this._direction];\n        }\n        if ('*' in this.options.animations[this._animation]) {\n            return this.options.animations[this._animation]['*'];\n        }\n        return this.options.animations[this._animation][directions[0]];\n    }\n    updateAnimationState(dt) {\n        if (!this.currentAnimationOptions || !this.currentAnimationState) {\n            return {\n                playing: true,\n                currentFrame: 0,\n                currentFrameTime: 0,\n            };\n        }\n        if (this.currentAnimationState.playing) {\n            const frameTime = 1 / this.currentAnimationOptions.frameRate;\n            this.currentAnimationState.currentFrameTime += dt;\n            if (this.currentAnimationState.currentFrameTime > frameTime) {\n                const frameCount = this.currentAnimationOptions.frameCount;\n                this.currentAnimationState.currentFrame++;\n                this.currentAnimationState.currentFrameTime = 0;\n                if (this.currentAnimationState.currentFrame >= frameCount) {\n                    switch (this.currentAnimationOptions.mode) {\n                        case SpriteAnimationRepeatMode.PlayOnceAndReset:\n                            this.currentAnimationState.playing = false;\n                            this.currentAnimationState.currentFrame = 0;\n                            break;\n                        case SpriteAnimationRepeatMode.PlayOnceAndStop:\n                            this.currentAnimationState.playing = false;\n                            this.currentAnimationState.currentFrame = frameCount - 1;\n                            break;\n                        case SpriteAnimationRepeatMode.Repeat:\n                            this.currentAnimationState.currentFrame = 0;\n                            break;\n                    }\n                }\n            }\n        }\n        return this.currentAnimationState;\n    }\n    updateImage() {\n        var _a, _b, _c;\n        if (!this.currentAnimationOptions || !this.currentAnimationState) {\n            return null;\n        }\n        if (!this.currentAnimationOptions.images ||\n            this.currentAnimationOptions.images.length === 0) {\n            return (_a = this.options.image) !== null && _a !== void 0 ? _a : null;\n        }\n        return ((_c = (_b = this.currentAnimationOptions.images[this.currentAnimationState.currentFrame]) !== null && _b !== void 0 ? _b : this.options.image) !== null && _c !== void 0 ? _c : null);\n    }\n    updateAttachmentPoints() {\n        if (!this.options.attachmentPoints ||\n            this.options.attachmentPoints.length === 0) {\n            return null;\n        }\n        if (!this.currentAttachmentPoints) {\n            this.currentAttachmentPoints = Object.fromEntries(this.options.attachmentPoints.map(attachmentPoint => [\n                attachmentPoint.name,\n                attachmentPoint.offset,\n            ]));\n        }\n        if (this.currentAnimationOptions &&\n            this.currentAnimationOptions.attachmentPointKeyframes &&\n            this.currentAnimationState) {\n            for (const name of Object.keys(this.currentAttachmentPoints)) {\n                if (name in this.currentAnimationOptions.attachmentPointKeyframes &&\n                    this.currentAnimationOptions.attachmentPointKeyframes[name].length > 0) {\n                    const previousKeyframe = this.findPreviousKeyframe(this.currentAnimationOptions.attachmentPointKeyframes[name], this.currentAnimationState.currentFrame);\n                    this.currentAttachmentPoints[name] = previousKeyframe.offset;\n                }\n            }\n        }\n        return this.currentAttachmentPoints;\n    }\n    findPreviousKeyframe(keyframes, currentFrame) {\n        const found = [...keyframes]\n            .reverse()\n            .find(keyframe => keyframe.frame <= currentFrame);\n        if (!found) {\n            return keyframes[keyframes.length - 1];\n        }\n        return found;\n    }\n    draw(context) {\n        var _a, _b, _c, _d;\n        context.save();\n        context.translate(this.position.x, this.position.y);\n        context.scale(this.scale, this.scale);\n        context.rotate(this.rotation);\n        (_b = (_a = this.options).preRender) === null || _b === void 0 ? void 0 : _b.call(_a, context, this);\n        if (this.currentImage) {\n            context.drawImage(this.currentImage, -this.origin.x, -this.origin.y, this.currentImage.width, this.currentImage.height);\n        }\n        (_d = (_c = this.options).postRender) === null || _d === void 0 ? void 0 : _d.call(_c, context, this);\n        if (this.options.debug.showSpriteBoundingBox) {\n            context.strokeStyle = Sprite.DEBUG_BOUNDING_BOX_COLOUR;\n            context.lineWidth = Sprite.DEBUG_BOUNDING_BOX_LINE_WIDTH;\n            context.strokeRect(-this.origin.x, -this.origin.y, this.size.x, this.size.y);\n        }\n        if (this.options.debug.showSpriteTransforms) {\n            this.drawTransformsMarker(context, (0, vec_1.vec2)(), Sprite.DEBUG_TRANSFORMS_COLOUR_X, Sprite.DEBUG_TRANSFORMS_COLOUR_Y, Sprite.DEBUG_TRANSFORMS_LINE_WIDTH, Sprite.DEBUG_TRANSFORMS_SIZE);\n        }\n        if (this.options.debug.showAttachmentPoints &&\n            this.currentAttachmentPoints) {\n            for (const attachmentPoint of Object.values(this.currentAttachmentPoints)) {\n                this.drawCross(context, attachmentPoint, Sprite.DEBUG_ATTACHMENT_POINT_COLOUR, Sprite.DEBUG_ATTACHMENT_POINT_LINE_WIDTH, Sprite.DEBUG_ATTACHMENT_POINT_SIZE);\n            }\n        }\n        context.restore();\n    }\n    drawTransformsMarker(context, position, xColour, yColour, lineWidth, size) {\n        context.save();\n        context.lineWidth = lineWidth;\n        context.strokeStyle = xColour;\n        context.beginPath();\n        context.moveTo(position.x, position.y);\n        context.lineTo(position.x + size, position.y);\n        context.stroke();\n        context.strokeStyle = yColour;\n        context.beginPath();\n        context.moveTo(position.x, position.y);\n        context.lineTo(position.x, position.y + size);\n        context.stroke();\n        context.restore();\n    }\n    drawCross(context, position, colour, lineWidth, size) {\n        context.save();\n        context.lineWidth = lineWidth;\n        const halfSize = Math.ceil(size / 2);\n        context.strokeStyle = colour;\n        context.beginPath();\n        context.moveTo(position.x - halfSize, position.y - halfSize);\n        context.lineTo(position.x + halfSize, position.y + halfSize);\n        context.moveTo(position.x - halfSize, position.y + halfSize);\n        context.lineTo(position.x + halfSize, position.y - halfSize);\n        context.stroke();\n        context.restore();\n    }\n}\nexports.Sprite = Sprite;\nSprite.DEFAULT_OPTIONS = {\n    directions: ['default'],\n    defaultDirection: 'default',\n    animations: {\n        default: {\n            '*': {\n                name: 'default',\n                frameCount: 1,\n                frameRate: 1,\n                mode: SpriteAnimationRepeatMode.PlayOnceAndStop,\n            },\n        },\n    },\n    defaultAnimation: 'default',\n};\nSprite.DEFAULT_ANIMATION_OPTIONS = {\n    name: 'default',\n    frameCount: 1,\n    frameRate: 1,\n    mode: SpriteAnimationRepeatMode.Repeat,\n};\nSprite.DEBUG_BOUNDING_BOX_COLOUR = 'green';\nSprite.DEBUG_BOUNDING_BOX_LINE_WIDTH = 2;\nSprite.DEBUG_TRANSFORMS_COLOUR_X = 'red';\nSprite.DEBUG_TRANSFORMS_COLOUR_Y = 'orange';\nSprite.DEBUG_TRANSFORMS_LINE_WIDTH = 1;\nSprite.DEBUG_TRANSFORMS_SIZE = 10;\nSprite.DEBUG_ATTACHMENT_POINT_COLOUR = 'blue';\nSprite.DEBUG_ATTACHMENT_POINT_LINE_WIDTH = 2;\nSprite.DEBUG_ATTACHMENT_POINT_SIZE = 5;\n// -----------------------------------------------------------------------------\n// CONTENT PROCESSOR\n// -----------------------------------------------------------------------------\n/**\n * Content Manager Processor wrapper which converts SpriteOptionsData into\n * SpriteOptions\n *\n * @see https://www.npmjs.com/package/@basementuniverse/content-manager\n */\nasync function spriteOptionsContentProcessor(content, data) {\n    if (!isSpriteOptionsData(data.content)) {\n        throw new Error('Invalid sprite config');\n    }\n    const getImageFromContent = (name) => {\n        var _a;\n        const image = (_a = content[name]) === null || _a === void 0 ? void 0 : _a.content;\n        if (!image) {\n            throw new Error(`Image '${name}' not found`);\n        }\n        return image;\n    };\n    const result = data.content;\n    if (result.imageName) {\n        result.image = getImageFromContent(result.imageName);\n        delete result.imageName;\n    }\n    if (result.animations) {\n        for (const [animationName, animation] of Object.entries(result.animations)) {\n            for (const [directionName, direction] of Object.entries(animation)) {\n                if (direction.imageNames) {\n                    result.animations[animationName][directionName].images =\n                        direction.imageNames.map(getImageFromContent);\n                    delete result.animations[animationName][directionName].imageNames;\n                }\n            }\n        }\n    }\n    data.content = result;\n}\nexports.spriteOptionsContentProcessor = spriteOptionsContentProcessor;\n\n\n//# sourceURL=webpack://@basementuniverse/sprite/./index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});